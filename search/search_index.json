{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"wdgrid API Documentation","text":""},{"location":"#wd.pareto","title":"<code>pareto</code>","text":"<p>Created on 2022-03-21</p> <p>@author: wf</p>"},{"location":"#wd.pareto.Pareto","title":"<code>Pareto</code>","text":"<p>               Bases: <code>object</code></p> <p>Pareto level holder</p> Source code in <code>wd/pareto.py</code> <pre><code>class Pareto(object):\n    \"\"\"\n    Pareto level holder\n    \"\"\"\n\n    def __init__(self, level: int = 1):\n        \"\"\"\n        Constructor\n\n        Args:\n            level(int): the pareto level\n\n        \"\"\"\n        self.level = level\n        self.good = 80.0\n        self.bad = 20.0\n        for _i in range(level - 1):\n            self.good = self.good + self.bad * 0.8\n            self.bad = 100.0 - self.good\n        self.decimals = 1 - round(math.log10(self.bad))\n        self.oneOutOf = round(100 / self.bad)\n        pass\n\n    def ratioInLevel(self, ratio) -&gt; bool:\n        \"\"\"\n        check whether the given ratio is in this level\n        \"\"\"\n        inLevel = ratio &gt;= 1 / self.oneOutOf\n        return inLevel\n\n    def asPercent(self):\n        percent = 100.0 / self.oneOutOf\n        return percent\n\n    def __str__(self):\n        text = self.asText(long=False)\n        return text\n\n    def asText(self, long: bool = False):\n        text = f\"{self.good:.{self.decimals}f}:{self.bad:.{self.decimals}f}\"\n        if long:\n            text = f\"level {self.level}={text} (1 out of {self.oneOutOf})\"\n        return text\n\n    def asDict(self) -&gt; dict:\n        \"\"\"\n        return me as a dict\n\n        Returns:\n            dict: my values as a dict\n        \"\"\"\n        d = {}\n        d[\"level\"] = self.level\n        d[\"ratio\"] = self.asText()\n        d[\"1 out of\"] = self.oneOutOf\n        return d\n</code></pre>"},{"location":"#wd.pareto.Pareto.__init__","title":"<code>__init__(level=1)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>level(int)</code> <p>the pareto level</p> required Source code in <code>wd/pareto.py</code> <pre><code>def __init__(self, level: int = 1):\n    \"\"\"\n    Constructor\n\n    Args:\n        level(int): the pareto level\n\n    \"\"\"\n    self.level = level\n    self.good = 80.0\n    self.bad = 20.0\n    for _i in range(level - 1):\n        self.good = self.good + self.bad * 0.8\n        self.bad = 100.0 - self.good\n    self.decimals = 1 - round(math.log10(self.bad))\n    self.oneOutOf = round(100 / self.bad)\n    pass\n</code></pre>"},{"location":"#wd.pareto.Pareto.asDict","title":"<code>asDict()</code>","text":"<p>return me as a dict</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>my values as a dict</p> Source code in <code>wd/pareto.py</code> <pre><code>def asDict(self) -&gt; dict:\n    \"\"\"\n    return me as a dict\n\n    Returns:\n        dict: my values as a dict\n    \"\"\"\n    d = {}\n    d[\"level\"] = self.level\n    d[\"ratio\"] = self.asText()\n    d[\"1 out of\"] = self.oneOutOf\n    return d\n</code></pre>"},{"location":"#wd.pareto.Pareto.ratioInLevel","title":"<code>ratioInLevel(ratio)</code>","text":"<p>check whether the given ratio is in this level</p> Source code in <code>wd/pareto.py</code> <pre><code>def ratioInLevel(self, ratio) -&gt; bool:\n    \"\"\"\n    check whether the given ratio is in this level\n    \"\"\"\n    inLevel = ratio &gt;= 1 / self.oneOutOf\n    return inLevel\n</code></pre>"},{"location":"#wd.query_view","title":"<code>query_view</code>","text":"<p>Created on 2024-01-04</p> <p>@author: wf</p>"},{"location":"#wd.query_view.QueryView","title":"<code>QueryView</code>","text":"<p>widget to display queries</p> Source code in <code>wd/query_view.py</code> <pre><code>class QueryView:\n    \"\"\"\n    widget to display queries\n    \"\"\"\n\n    def __init__(\n        self, webserver: NiceGuiWebserver, name: str, sparql_endpoint: Endpoint\n    ):\n        \"\"\"\n        Initialize the QueryView object with a given webserver and name.\n\n        Args:\n            webserver (NiceGuiWebserver): The web server instance to be used.\n            name (str): The name identifier for the query display.\n            sparql_endpoint(endpoint): the SPARQL endpoint to use\n        \"\"\"\n        self.webserver = webserver\n        self.name = name\n        self.setup()\n        self.sparql_query = \"\"\n        self.sparql_markup = \"\"\n        self.sparql_endpoint = sparql_endpoint\n\n    def setup(self):\n        \"\"\"Set up the UI components for the query display.\"\"\"\n        with ui.expansion(self.name) as self.expansion:\n            self.code_view = ui.code(\"\", language=\"sparql\")\n        with ui.row() as self.link_row:\n            self.try_it_link_view = ui.html()\n            self.download_link_view = ui.html()\n            pass\n\n    def show_query(self, sparql_query: str):\n        \"\"\"\n        Update the display with a new SPARQL query.\n\n        Args:\n            sparql_query (str): The SPARQL query string to be displayed.\n        \"\"\"\n        self.sparql_query = sparql_query.strip()\n        # we might need to change the endpoint\n        self.query = Query(name=self.name, query=sparql_query)\n        if self.sparql_endpoint:\n            try_it_url_encoded = self.query.getTryItUrl(\n                baseurl=self.sparql_endpoint.website,\n                database=self.sparql_endpoint.database,\n            )\n            with self.link_row:\n                try_it_link = Link.create(try_it_url_encoded, \"try it!\")\n                self.try_it_link_view.content = try_it_link\n        with self.expansion:\n            self.code_view.markdown.content = f\"\"\"```sparql\n    {sparql_query}\n    ```\"\"\"\n            self.code_view.update()\n        pass\n</code></pre>"},{"location":"#wd.query_view.QueryView.__init__","title":"<code>__init__(webserver, name, sparql_endpoint)</code>","text":"<p>Initialize the QueryView object with a given webserver and name.</p> <p>Parameters:</p> Name Type Description Default <code>webserver</code> <code>NiceGuiWebserver</code> <p>The web server instance to be used.</p> required <code>name</code> <code>str</code> <p>The name identifier for the query display.</p> required <code>sparql_endpoint(endpoint)</code> <p>the SPARQL endpoint to use</p> required Source code in <code>wd/query_view.py</code> <pre><code>def __init__(\n    self, webserver: NiceGuiWebserver, name: str, sparql_endpoint: Endpoint\n):\n    \"\"\"\n    Initialize the QueryView object with a given webserver and name.\n\n    Args:\n        webserver (NiceGuiWebserver): The web server instance to be used.\n        name (str): The name identifier for the query display.\n        sparql_endpoint(endpoint): the SPARQL endpoint to use\n    \"\"\"\n    self.webserver = webserver\n    self.name = name\n    self.setup()\n    self.sparql_query = \"\"\n    self.sparql_markup = \"\"\n    self.sparql_endpoint = sparql_endpoint\n</code></pre>"},{"location":"#wd.query_view.QueryView.setup","title":"<code>setup()</code>","text":"<p>Set up the UI components for the query display.</p> Source code in <code>wd/query_view.py</code> <pre><code>def setup(self):\n    \"\"\"Set up the UI components for the query display.\"\"\"\n    with ui.expansion(self.name) as self.expansion:\n        self.code_view = ui.code(\"\", language=\"sparql\")\n    with ui.row() as self.link_row:\n        self.try_it_link_view = ui.html()\n        self.download_link_view = ui.html()\n        pass\n</code></pre>"},{"location":"#wd.query_view.QueryView.show_query","title":"<code>show_query(sparql_query)</code>","text":"<p>Update the display with a new SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>sparql_query</code> <code>str</code> <p>The SPARQL query string to be displayed.</p> required Source code in <code>wd/query_view.py</code> <pre><code>def show_query(self, sparql_query: str):\n    \"\"\"\n    Update the display with a new SPARQL query.\n\n    Args:\n        sparql_query (str): The SPARQL query string to be displayed.\n    \"\"\"\n    self.sparql_query = sparql_query.strip()\n    # we might need to change the endpoint\n    self.query = Query(name=self.name, query=sparql_query)\n    if self.sparql_endpoint:\n        try_it_url_encoded = self.query.getTryItUrl(\n            baseurl=self.sparql_endpoint.website,\n            database=self.sparql_endpoint.database,\n        )\n        with self.link_row:\n            try_it_link = Link.create(try_it_url_encoded, \"try it!\")\n            self.try_it_link_view.content = try_it_link\n    with self.expansion:\n        self.code_view.markdown.content = f\"\"\"```sparql\n{sparql_query}\n```\"\"\"\n        self.code_view.update()\n    pass\n</code></pre>"},{"location":"#wd.truly_tabular_display","title":"<code>truly_tabular_display</code>","text":"<p>Created on 2024-01-04</p> <p>@author: wf</p>"},{"location":"#wd.truly_tabular_display.PropertySelection","title":"<code>PropertySelection</code>","text":"<p>select properties</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>class PropertySelection:\n    \"\"\"\n    select properties\n    \"\"\"\n\n    def __init__(\n        self,\n        inputList,\n        total: int,\n        paretoLevels: Dict[int, Pareto],\n        minFrequency: float,\n    ):\n        \"\"\"\n           Constructor\n\n        Args:\n            propertyList(list): the list of properties to show\n            total(int): total number of properties\n            paretolLevels: a dict of paretoLevels with the key corresponding to the level\n            minFrequency(float): the minimum frequency of the properties to select in percent\n        \"\"\"\n        self.propertyMap: Dict[str, dict] = dict()\n        self.headerMap = {}\n        self.propertyList = []\n        self.total = total\n        self.paretoLevels = paretoLevels\n        self.minFrequency = minFrequency\n        for record in inputList:\n            ratio = int(record[\"count\"]) / self.total\n            level = self.getParetoLevel(ratio)\n            record[\"%\"] = f\"{ratio*100:.1f}\"\n            record[\"pareto\"] = level\n            # if record[\"pareto\"]&lt;=paretoLimit:\n            orecord = collections.OrderedDict(record.copy())\n            self.propertyList.append(orecord)\n        pass\n\n    @property\n    def aggregates(self) -&gt; list:\n        aggregates = [\"min\", \"max\", \"avg\", \"sample\", \"list\", \"count\"]\n        return aggregates\n\n    @property\n    def option_cols(self) -&gt; list:\n        option_cols = [\"ignore\", \"label\"]\n        return option_cols\n\n    @property\n    def checkbox_cols(self) -&gt; list:\n        \"\"\"\n        get all my checkbox columns\n        \"\"\"\n        checkbox_cols = self.aggregates\n        checkbox_cols.extend(self.option_cols)\n        return checkbox_cols\n\n    def getParetoLevel(self, ratio):\n        level = 0\n        for pareto in reversed(self.paretoLevels.values()):\n            if pareto.ratioInLevel(ratio):\n                level = pareto.level\n        return level\n\n    def getInfoHeaderColumn(self, col: str) -&gt; str:\n        href = f\"https://wiki.bitplan.com/index.php/Truly_Tabular_RDF/Info#{col}\"\n        info = f\"{col}&lt;br&gt;&lt;a href='{href}'style='color:white' target='_blank'&gt;\u24d8&lt;/a&gt;\"\n        return info\n\n    def hasMinFrequency(self, record: dict) -&gt; bool:\n        \"\"\"\n        Check if the frequency of the given property record is greater than the minimal frequency\n\n        Returns:\n            True if property frequency is greater or equal than the minFrequency. Otherwise False\n        \"\"\"\n        ok = float(record.get(\"%\", 0)) &gt;= self.minFrequency\n        return ok\n\n    def select(self) -&gt; List[Tuple[str, dict]]:\n        \"\"\"\n        select all properties that fulfill hasMinFrequency\n\n        Returns:\n            list of all selected properties as tuple list consisting of property id and record\n        \"\"\"\n        selected = []\n        for propertyId, propRecord in self.propertyMap.items():\n            if self.hasMinFrequency(propRecord):\n                selected.append((propertyId, propRecord))\n        return selected\n\n    def prepare(self):\n        \"\"\"\n        prepare the propertyList\n\n        Args:\n            total(int): the total number of records\n            paretoLevels(list): the pareto Levels to use\n        \"\"\"\n\n        self.headerMap = {}\n        cols = [\n            \"#\",\n            \"%\",\n            \"pareto\",\n            \"property\",\n            \"propertyId\",\n            \"type\",\n            \"1\",\n            \"maxf\",\n            \"nt\",\n            \"nt%\",\n            \"?f\",\n            \"?ex\",\n            \"\u2714\",\n        ]\n        cols.extend(self.checkbox_cols)\n        for col in cols:\n            self.headerMap[col] = self.getInfoHeaderColumn(col)\n        for i, prop in enumerate(self.propertyList):\n            # add index as first column\n            prop[\"#\"] = i + 1\n            prop.move_to_end(\"#\", last=False)\n            propLabel = prop.pop(\"propLabel\")\n            url = prop.pop(\"prop\")\n            itemId = url.replace(\"http://www.wikidata.org/entity/\", \"\")\n            prop[\"propertyId\"] = itemId\n            prop[\"property\"] = Link.create(url, propLabel)\n            prop[\"type\"] = prop.pop(\"wbType\").replace(\"http://wikiba.se/ontology#\", \"\")\n            prop[\"1\"] = \"\"\n            prop[\"maxf\"] = \"\"\n            prop[\"nt\"] = \"\"\n            prop[\"nt%\"] = \"\"\n            prop[\"?f\"] = \"\"\n            prop[\"?ex\"] = \"\"\n            prop[\"\u2714\"] = \"\"\n            # workaround count being first element\n            prop[\"count\"] = prop.pop(\"count\")\n            for col in self.checkbox_cols:\n                prop[col] = False\n\n            self.propertyMap[itemId] = prop\n</code></pre>"},{"location":"#wd.truly_tabular_display.PropertySelection.checkbox_cols","title":"<code>checkbox_cols: list</code>  <code>property</code>","text":"<p>get all my checkbox columns</p>"},{"location":"#wd.truly_tabular_display.PropertySelection.__init__","title":"<code>__init__(inputList, total, paretoLevels, minFrequency)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>propertyList(list)</code> <p>the list of properties to show</p> required <code>total(int)</code> <p>total number of properties</p> required <code>paretolLevels</code> <p>a dict of paretoLevels with the key corresponding to the level</p> required <code>minFrequency(float)</code> <p>the minimum frequency of the properties to select in percent</p> required Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def __init__(\n    self,\n    inputList,\n    total: int,\n    paretoLevels: Dict[int, Pareto],\n    minFrequency: float,\n):\n    \"\"\"\n       Constructor\n\n    Args:\n        propertyList(list): the list of properties to show\n        total(int): total number of properties\n        paretolLevels: a dict of paretoLevels with the key corresponding to the level\n        minFrequency(float): the minimum frequency of the properties to select in percent\n    \"\"\"\n    self.propertyMap: Dict[str, dict] = dict()\n    self.headerMap = {}\n    self.propertyList = []\n    self.total = total\n    self.paretoLevels = paretoLevels\n    self.minFrequency = minFrequency\n    for record in inputList:\n        ratio = int(record[\"count\"]) / self.total\n        level = self.getParetoLevel(ratio)\n        record[\"%\"] = f\"{ratio*100:.1f}\"\n        record[\"pareto\"] = level\n        # if record[\"pareto\"]&lt;=paretoLimit:\n        orecord = collections.OrderedDict(record.copy())\n        self.propertyList.append(orecord)\n    pass\n</code></pre>"},{"location":"#wd.truly_tabular_display.PropertySelection.hasMinFrequency","title":"<code>hasMinFrequency(record)</code>","text":"<p>Check if the frequency of the given property record is greater than the minimal frequency</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if property frequency is greater or equal than the minFrequency. Otherwise False</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def hasMinFrequency(self, record: dict) -&gt; bool:\n    \"\"\"\n    Check if the frequency of the given property record is greater than the minimal frequency\n\n    Returns:\n        True if property frequency is greater or equal than the minFrequency. Otherwise False\n    \"\"\"\n    ok = float(record.get(\"%\", 0)) &gt;= self.minFrequency\n    return ok\n</code></pre>"},{"location":"#wd.truly_tabular_display.PropertySelection.prepare","title":"<code>prepare()</code>","text":"<p>prepare the propertyList</p> <p>Parameters:</p> Name Type Description Default <code>total(int)</code> <p>the total number of records</p> required <code>paretoLevels(list)</code> <p>the pareto Levels to use</p> required Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def prepare(self):\n    \"\"\"\n    prepare the propertyList\n\n    Args:\n        total(int): the total number of records\n        paretoLevels(list): the pareto Levels to use\n    \"\"\"\n\n    self.headerMap = {}\n    cols = [\n        \"#\",\n        \"%\",\n        \"pareto\",\n        \"property\",\n        \"propertyId\",\n        \"type\",\n        \"1\",\n        \"maxf\",\n        \"nt\",\n        \"nt%\",\n        \"?f\",\n        \"?ex\",\n        \"\u2714\",\n    ]\n    cols.extend(self.checkbox_cols)\n    for col in cols:\n        self.headerMap[col] = self.getInfoHeaderColumn(col)\n    for i, prop in enumerate(self.propertyList):\n        # add index as first column\n        prop[\"#\"] = i + 1\n        prop.move_to_end(\"#\", last=False)\n        propLabel = prop.pop(\"propLabel\")\n        url = prop.pop(\"prop\")\n        itemId = url.replace(\"http://www.wikidata.org/entity/\", \"\")\n        prop[\"propertyId\"] = itemId\n        prop[\"property\"] = Link.create(url, propLabel)\n        prop[\"type\"] = prop.pop(\"wbType\").replace(\"http://wikiba.se/ontology#\", \"\")\n        prop[\"1\"] = \"\"\n        prop[\"maxf\"] = \"\"\n        prop[\"nt\"] = \"\"\n        prop[\"nt%\"] = \"\"\n        prop[\"?f\"] = \"\"\n        prop[\"?ex\"] = \"\"\n        prop[\"\u2714\"] = \"\"\n        # workaround count being first element\n        prop[\"count\"] = prop.pop(\"count\")\n        for col in self.checkbox_cols:\n            prop[col] = False\n\n        self.propertyMap[itemId] = prop\n</code></pre>"},{"location":"#wd.truly_tabular_display.PropertySelection.select","title":"<code>select()</code>","text":"<p>select all properties that fulfill hasMinFrequency</p> <p>Returns:</p> Type Description <code>List[Tuple[str, dict]]</code> <p>list of all selected properties as tuple list consisting of property id and record</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def select(self) -&gt; List[Tuple[str, dict]]:\n    \"\"\"\n    select all properties that fulfill hasMinFrequency\n\n    Returns:\n        list of all selected properties as tuple list consisting of property id and record\n    \"\"\"\n    selected = []\n    for propertyId, propRecord in self.propertyMap.items():\n        if self.hasMinFrequency(propRecord):\n            selected.append((propertyId, propRecord))\n    return selected\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularConfig","title":"<code>TrulyTabularConfig</code>  <code>dataclass</code>","text":"<p>Configuration class for Truly Tabular operations.</p> <p>Attributes:</p> Name Type Description <code>lang</code> <code>str</code> <p>Language code (default is \"en\").</p> <code>list_separator</code> <code>str</code> <p>Character used to separate items in lists (default is \"|\").</p> <code>endpoint_name</code> <code>str</code> <p>Name of the endpoint to use (default is \"wikidata\").</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>@dataclass\nclass TrulyTabularConfig:\n    \"\"\"\n    Configuration class for Truly Tabular operations.\n\n    Attributes:\n        lang (str): Language code (default is \"en\").\n        list_separator (str): Character used to separate items in lists (default is \"|\").\n        endpoint_name (str): Name of the endpoint to use (default is \"wikidata\").\n    \"\"\"\n\n    lang: str = \"en\"\n    list_separator: str = \"|\"\n    endpoint_name: str = \"wikidata\"\n    pareto_level = 1\n    # minimum percentual frequency of availability\n    min_property_frequency = 20.0\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization to setup additional attributes.\n        \"\"\"\n        self.endpoints = EndpointManager.getEndpoints(lang=\"sparql\")\n        self.languages = Lang.get_language_dict()\n        self.pareto_levels = {}\n        self.pareto_select = {}\n        for level in range(1, 10):\n            pareto = Pareto(level)\n            self.pareto_levels[level] = pareto\n            self.pareto_select[level] = pareto.asText(long=True)\n        pass\n\n    @property\n    def sparql_endpoint(self) -&gt; Endpoint:\n        endpoint = self.endpoints.get(self.endpoint_name, None)\n        return endpoint\n\n    @property\n    def pareto(self) -&gt; Pareto:\n        pareto = self.pareto_levels[self.pareto_level]\n        return pareto\n\n    def setup_ui(self, webserver):\n        \"\"\"\n        setup the user interface\n        \"\"\"\n        with ui.grid(columns=2):\n            webserver.add_select(\"lang\", self.languages, with_input=True).bind_value(\n                self, \"lang\"\n            )\n            list_separators = {\n                \"|\": \"|\",\n                \",\": \",\",\n                \";\": \";\",\n                \":\": \":\",\n                \"\\x1c\": \"FS - ASCII(28)\",\n                \"\\x1d\": \"GS - ASCII(29)\",\n                \"\\x1e\": \"RS - ASCII(30)\",\n                \"\\x1f\": \"US - ASCII(31)\",\n            }\n            webserver.add_select(\"List separator\", list_separators).bind_value(\n                self, \"list_separator\"\n            )\n            webserver.add_select(\"Endpoint\", list(self.endpoints.keys())).bind_value(\n                self, \"endpoint_name\"\n            )\n            webserver.add_select(\"Pareto level\", self.pareto_select).bind_value(\n                self, \"pareto_level\"\n            )\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization to setup additional attributes.</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization to setup additional attributes.\n    \"\"\"\n    self.endpoints = EndpointManager.getEndpoints(lang=\"sparql\")\n    self.languages = Lang.get_language_dict()\n    self.pareto_levels = {}\n    self.pareto_select = {}\n    for level in range(1, 10):\n        pareto = Pareto(level)\n        self.pareto_levels[level] = pareto\n        self.pareto_select[level] = pareto.asText(long=True)\n    pass\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularConfig.setup_ui","title":"<code>setup_ui(webserver)</code>","text":"<p>setup the user interface</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def setup_ui(self, webserver):\n    \"\"\"\n    setup the user interface\n    \"\"\"\n    with ui.grid(columns=2):\n        webserver.add_select(\"lang\", self.languages, with_input=True).bind_value(\n            self, \"lang\"\n        )\n        list_separators = {\n            \"|\": \"|\",\n            \",\": \",\",\n            \";\": \";\",\n            \":\": \":\",\n            \"\\x1c\": \"FS - ASCII(28)\",\n            \"\\x1d\": \"GS - ASCII(29)\",\n            \"\\x1e\": \"RS - ASCII(30)\",\n            \"\\x1f\": \"US - ASCII(31)\",\n        }\n        webserver.add_select(\"List separator\", list_separators).bind_value(\n            self, \"list_separator\"\n        )\n        webserver.add_select(\"Endpoint\", list(self.endpoints.keys())).bind_value(\n            self, \"endpoint_name\"\n        )\n        webserver.add_select(\"Pareto level\", self.pareto_select).bind_value(\n            self, \"pareto_level\"\n        )\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay","title":"<code>TrulyTabularDisplay</code>","text":"<p>Displays a truly tabular analysis for a given Wikidata item</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>class TrulyTabularDisplay:\n    \"\"\"\n    Displays a truly tabular analysis for a given Wikidata\n    item\n    \"\"\"\n\n    def __init__(self, solution: \"WdgridSolution\", qid: str):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.solution = solution\n        self.config = solution.tt_config\n        self.search_predicate = \"wdt:P31\"\n        self.qid = qid\n        self.tt = None\n        self.naive_query_view = None\n        self.aggregate_query_view = None\n        self.setup()\n\n    async def ui_yield(self):\n        await asyncio.sleep(0)  # allow other tasks to run on the event loop\n\n    @staticmethod\n    def isTimeoutException(ex: EndPointInternalError):\n        \"\"\"\n        Checks if the given exception is a query timeout exception\n\n        Returns:\n            True if the given exception is caused by a query timeout\n        \"\"\"\n        check_for = \"java.util.concurrent.TimeoutException\"\n        msg = ex.args[0]\n        res = False\n        if isinstance(msg, str):\n            if check_for in msg:\n                res = True\n        return res\n\n    def setup(self):\n        \"\"\"\n        set up the user interface\n        \"\"\"\n        with ui.element(\"div\").classes(\"w-full\") as self.main_container:\n            with ui.splitter() as splitter:\n                with splitter.before:\n                    with ui.row() as self.sp_row:\n                        self.item_input = ui.input(\n                            \"item\", value=self.qid, on_change=self.update_display\n                        ).bind_value(self, \"qid\")\n                        predicates = {\n                            \"wdt:P31\": \"instance of\",\n                            \"wdt:P31/wdt:P279*\": \"subclass of\",\n                            \"wdt:P179\": \"part of the series\",\n                        }\n                        self.solution.add_select(\n                            \"predicate\",\n                            predicates,\n                            with_input=True,\n                            value=self.search_predicate,\n                            on_change=self.update_display,\n                        ).bind_value(self, \"search_predicate\")\n\n                    with ui.row() as self.item_row:\n                        self.item_link_view = ui.html()\n                        self.item_count_view = ui.html()\n                    with ui.row():\n                        self.solution.add_select(\n                            \"Pareto level\",\n                            self.config.pareto_select,\n                            on_change=self.on_pareto_change,\n                        ).bind_value(self.config, \"pareto_level\")\n                        self.min_property_frequency_input = ui.input(\n                            \"min%\",\n                            value=str(self.config.min_property_frequency),\n                        ).on(\"keydown.enter\", self.on_min_property_frequency_change)\n                with splitter.after as self.query_display_container:\n                    self.count_query_view = QueryView(\n                        self.solution,\n                        name=\"count Query\",\n                        sparql_endpoint=self.config.sparql_endpoint,\n                    )\n                    self.property_query_view = QueryView(\n                        self.solution,\n                        name=\"property Query\",\n                        sparql_endpoint=self.config.sparql_endpoint,\n                    )\n            with ui.row() as self.generate_button_row:\n                self.generate_button = ui.button(\n                    \"Generate SPARQL queries\", on_click=self.on_generate_button_click\n                )\n                self.generate_button.disable()\n            with ui.row() as self.progressbar_row:\n                self.progress_bar = NiceguiProgressbar(\n                    total=0, desc=\"Property statistics\", unit=\"prop\"\n                )\n            with ui.row() as self.property_grid_row:\n                config = GridConfig(multiselect=True)\n                self.property_grid = ListOfDictsGrid(config=config)\n        # immediately do an async call of update view\n        # ui.timer(0, self.update_display, once=True)\n\n    def createTrulyTabular(self, itemQid: str, propertyIds=[]):\n        \"\"\"\n        create a Truly Tabular configuration for my configure endpoint and the given itemQid and\n        propertyIds\n\n        Args:\n            itemQid(str): e.g. Q5 human\n            propertyIds(list): list of property Ids (if any) such as P17 country\n        \"\"\"\n        tt = TrulyTabular(\n            itemQid=itemQid,\n            propertyIds=propertyIds,\n            search_predicate=self.search_predicate,\n            endpointConf=self.config.sparql_endpoint,\n            debug=self.solution.debug,\n        )\n        return tt\n\n    def wikiTrulyTabularPropertyStats(self, itemId: str, propertyId: str):\n        \"\"\"\n        get the truly tabular property statistics\n\n        Args:\n            itemId(str): the Wikidata item identifier\n            propertyId(str): the property id\n        \"\"\"\n        try:\n            tt = self.createTrulyTabular(itemId, propertyIds=[propertyId])\n            statsRow = next(tt.genPropertyStatistics())\n            for key in [\"queryf\", \"queryex\"]:\n                queryText = statsRow[key]\n                sparql = f\"# This query was generated by Truly Tabular\\n{queryText}\"\n                query = Query(name=key, query=sparql)\n                tryItUrlEncoded = query.getTryItUrl(\n                    baseurl=self.config.sparql_endpoint.website,\n                    database=self.config.sparql_endpoint.database,\n                )\n                tryItLink = Link.create(\n                    url=tryItUrlEncoded,\n                    text=\"try it!\",\n                    tooltip=f\"try out with {self.config.sparql_endpoint.name}\",\n                    target=\"_blank\",\n                )\n                statsRow[f\"{key}TryIt\"] = tryItLink\n            return statsRow\n        except (BaseException, HTTPError) as ex:\n            self.solution.handle_exception(ex)\n            return None\n\n    async def getPropertyIdMap(self) -&gt; Dict:\n        \"\"\"\n        get the map of selected property ids\n        with generation specs\n\n        Returns:\n            dict: a dict of list\n        \"\"\"\n        idMap = {}\n        cols = self.property_selection.checkbox_cols\n        selected_rows = await self.property_grid.get_selected_rows()\n        for srow in selected_rows:\n            propertyId = srow[\"propertyId\"]\n            key_value = srow[\"#\"]\n            genList = []\n            for col_key in cols:\n                checked = self.property_grid.get_cell_value(key_value, col_key)\n                if checked:\n                    genList.append(col_key)\n            idMap[propertyId] = genList\n        return idMap\n\n    async def generateQueries(self):\n        \"\"\"\n        generate and show the queries\n        \"\"\"\n        try:\n            propertyIdMap = await self.getPropertyIdMap()\n            tt = self.createTrulyTabular(\n                itemQid=self.qid, propertyIds=list(propertyIdMap.keys())\n            )\n\n            if self.naive_query_view is None:\n                with self.query_display_container:\n                    self.naive_query_view = QueryView(\n                        self.solution,\n                        name=\"naive Query\",\n                        sparql_endpoint=self.config.sparql_endpoint,\n                    )\n            if self.aggregate_query_view is None:\n                with self.query_display_container:\n                    self.aggregate_query_view = QueryView(\n                        self.solution,\n                        name=\"aggregate Query\",\n                        sparql_endpoint=self.config.sparql_endpoint,\n                    )\n            sparqlQuery = tt.generateSparqlQuery(\n                genMap=propertyIdMap,\n                naive=True,\n                lang=self.config.lang,\n                listSeparator=self.config.list_separator,\n            )\n            naiveSparqlQuery = Query(name=\"naive SPARQL Query\", query=sparqlQuery)\n            self.naive_query_view.show_query(naiveSparqlQuery.query)\n            sparqlQuery = tt.generateSparqlQuery(\n                genMap=propertyIdMap,\n                naive=False,\n                lang=self.config.lang,\n                listSeparator=self.config.list_separator,\n            )\n            self.aggregateSparqlQuery = Query(\n                name=\"aggregate SPARQL Query\", query=sparqlQuery\n            )\n            self.aggregate_query_view.show_query(self.aggregateSparqlQuery.query)\n            ui.notify(\"SPARQL queries generated\")\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    async def on_generate_button_click(self, _event):\n        \"\"\"\n        handle the generate button click\n        \"\"\"\n        try:\n            ui.notify(f\"generating SPARQL query for {str(self.tt)}\")\n            await self.generateQueries()\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    async def on_min_property_frequency_change(self, _event):\n        \"\"\"\n        handle a change in the minimum property frequency input\n        \"\"\"\n        value_str = self.min_property_frequency_input.value\n        try:\n            self.config.min_property_frequency = float(value_str)\n            ui.notify(f\"new freq: {self.config.min_property_frequency}\")\n            await self.update_display()\n        except Exception as _ex:\n            ui.notify(f\"invalid frequency value {value_str}\")\n            pass\n\n    async def on_pareto_change(self, _event):\n        \"\"\"\n        handle changes in the pareto level\n        \"\"\"\n        ui.notify(f\"pareto level changed to {self.config.pareto_level} \")\n        self.config.min_property_frequency = self.config.pareto.asPercent()\n        self.min_property_frequency_input.value = str(\n            self.config.min_property_frequency\n        )\n\n    def get_stats_rows(self, property_grid_rows: list):\n        \"\"\"\n        get the statistic rows for the given property_grid_rows\n        \"\"\"\n        for row in property_grid_rows:\n            property_id = row[\"propertyId\"]\n            row_key = row[\"#\"]\n            stats_row = self.wikiTrulyTabularPropertyStats(self.tt.itemQid, property_id)\n            if stats_row:\n                stats_row[\"\u2714\"] = \"\u2714\"\n            else:\n                stats_row = {\"\u2714\": \"\u274c\"}\n            for col_key, statsColumn in [\n                (\"1\", \"1\"),\n                (\"maxf\", \"maxf\"),\n                (\"nt\", \"non tabular\"),\n                (\"nt%\", \"non tabular%\"),\n                (\"?f\", \"queryfTryIt\"),\n                (\"?ex\", \"queryexTryIt\"),\n                (\"\u2714\", \"\u2714\"),\n            ]:\n                if statsColumn in stats_row:\n                    value = stats_row[statsColumn]\n                    self.property_grid.update_cell(row_key, col_key, value)\n            self.property_grid.update()\n            pass\n\n    def update_item_count_view(self):\n        \"\"\"\n        update the item count\n        \"\"\"\n        try:\n            self.ttcount, countQuery = self.tt.count()\n            self.count_query_view.show_query(countQuery)\n            content = \"\u2753\" if self.tt.error else f\"{self.ttcount} instances found\"\n            with self.item_row:\n                self.item_count_view.content = content\n            if not self.tt.error:\n                self.update_property_query_view(total=self.ttcount)\n\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    def update_property_query_view(self, total: int):\n        \"\"\"\n        update the property query view\n        \"\"\"\n        try:\n            pareto = self.config.pareto\n            if total is not None:\n                min_count = round(total * self.config.min_property_frequency / 100.0)\n            else:\n                min_count = 0\n            msg = f\"searching properties with at least {min_count} usages\"\n            with self.main_container:\n                ui.notify(msg)\n            mfp_query = self.tt.mostFrequentPropertiesQuery(minCount=min_count)\n            self.property_query_view.show_query(mfp_query.query)\n            self.update_properties_table(mfp_query)\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    def prepare_generation_specs(self):\n        \"\"\"\n        prepare the interactive generation specification\n        \"\"\"\n        # render generation spec columns as checkboxes\n        for col in self.property_selection.checkbox_cols:\n            self.property_grid.set_checkbox_renderer(col)\n            pass\n        for row in self.property_selection.propertyList:\n            has_min_frequency = self.property_selection.hasMinFrequency(row)\n            row[\"count\"] = True\n            if has_min_frequency:\n                if row[\"type\"] == \"WikibaseItem\":\n                    row[\"label\"] = True\n            else:\n                row[\"ignore\"] = True\n            pass\n        col_def = self.property_grid.get_column_def(\"#\")\n        col_def[\"headerCheckboxSelection\"] = True\n        self.property_grid.update()\n        self.property_grid.select_all_rows()\n        self.generate_button.enable()\n\n    def update_properties_table(self, mfp_query):\n        \"\"\"\n        update my properties table\n\n        Args:\n            mfp_query(Query): the query for the most frequently used properties\n        \"\"\"\n        try:\n            with self.query_display_container:\n                msg = f\"running query for most frequently used properties of {str(self.tt)} ...\"\n                ui.notify(msg)\n            try:\n                property_lod = self.tt.sparql.queryAsListOfDicts(mfp_query.query)\n            except EndPointInternalError as ex:\n                if self.isTimeoutException(ex):\n                    raise Exception(\"Query timeout of the property table query\")\n            self.property_selection = PropertySelection(\n                property_lod,\n                total=self.ttcount,\n                paretoLevels=self.config.pareto_levels,\n                minFrequency=self.config.min_property_frequency,\n            )\n            self.property_selection.prepare()\n            with self.property_grid_row:\n                self.view_lod = self.property_selection.propertyList\n                self.property_grid.load_lod(self.view_lod)\n                self.property_grid.set_checkbox_selection(\"#\")\n                self.property_grid.update()\n            self.update_property_stats()\n            self.prepare_generation_specs()\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    def update_property_stats(self):\n        \"\"\"\n        update the property statistics\n        \"\"\"\n        try:\n            count = len(self.property_selection.propertyList)\n            with self.main_container:\n                ui.notify(f\"Getting property statistics for {count} properties\")\n                self.progress_bar.total = count\n                self.progress_bar.reset()\n            for row in self.property_selection.propertyList:\n                # run in background\n                asyncio.run(run.io_bound(self.get_stats_rows, [row]))\n                with self.main_container:\n                    self.progress_bar.update(1)\n            pass\n            with self.main_container:\n                self.progress_bar.reset()\n                ui.notify(f\"Done getting statistics for {count} properties\")\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    async def on_property_grid_selection_change(self, event):\n        \"\"\"\n        the property grid selection has changed\n        \"\"\"\n        source = event.args.get(\"source\", None)\n        if source == \"checkboxSelected\":\n            selected_rows = await self.property_grid.get_selected_rows()\n            ui.notify(f\"Selection changed: {selected_rows}\")\n\n    async def update_item_link_view(self):\n        with self.item_row:\n            item_text = self.tt.item.asText(long=True)\n            item_url = self.tt.item.url\n            item_link = Link.create(item_url, item_text)\n            self.item_link_view.content = item_link\n\n    async def update_display(self):\n        \"\"\"\n        update the display\n        \"\"\"\n        try:\n            if self.solution.log_view:\n                self.solution.log_view.clear()\n            self.tt = self.createTrulyTabular(self.qid)\n            for query_view in self.count_query_view, self.property_query_view:\n                query_view.sparql_endpoint = self.config.sparql_endpoint\n            # Initialize TrulyTabular with the qid\n            await self.update_item_link_view()\n            await run.io_bound(self.update_item_count_view)\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.__init__","title":"<code>__init__(solution, qid)</code>","text":"<p>constructor</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def __init__(self, solution: \"WdgridSolution\", qid: str):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.solution = solution\n    self.config = solution.tt_config\n    self.search_predicate = \"wdt:P31\"\n    self.qid = qid\n    self.tt = None\n    self.naive_query_view = None\n    self.aggregate_query_view = None\n    self.setup()\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.createTrulyTabular","title":"<code>createTrulyTabular(itemQid, propertyIds=[])</code>","text":"<p>create a Truly Tabular configuration for my configure endpoint and the given itemQid and propertyIds</p> <p>Parameters:</p> Name Type Description Default <code>itemQid(str)</code> <p>e.g. Q5 human</p> required <code>propertyIds(list)</code> <p>list of property Ids (if any) such as P17 country</p> required Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def createTrulyTabular(self, itemQid: str, propertyIds=[]):\n    \"\"\"\n    create a Truly Tabular configuration for my configure endpoint and the given itemQid and\n    propertyIds\n\n    Args:\n        itemQid(str): e.g. Q5 human\n        propertyIds(list): list of property Ids (if any) such as P17 country\n    \"\"\"\n    tt = TrulyTabular(\n        itemQid=itemQid,\n        propertyIds=propertyIds,\n        search_predicate=self.search_predicate,\n        endpointConf=self.config.sparql_endpoint,\n        debug=self.solution.debug,\n    )\n    return tt\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.generateQueries","title":"<code>generateQueries()</code>  <code>async</code>","text":"<p>generate and show the queries</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>async def generateQueries(self):\n    \"\"\"\n    generate and show the queries\n    \"\"\"\n    try:\n        propertyIdMap = await self.getPropertyIdMap()\n        tt = self.createTrulyTabular(\n            itemQid=self.qid, propertyIds=list(propertyIdMap.keys())\n        )\n\n        if self.naive_query_view is None:\n            with self.query_display_container:\n                self.naive_query_view = QueryView(\n                    self.solution,\n                    name=\"naive Query\",\n                    sparql_endpoint=self.config.sparql_endpoint,\n                )\n        if self.aggregate_query_view is None:\n            with self.query_display_container:\n                self.aggregate_query_view = QueryView(\n                    self.solution,\n                    name=\"aggregate Query\",\n                    sparql_endpoint=self.config.sparql_endpoint,\n                )\n        sparqlQuery = tt.generateSparqlQuery(\n            genMap=propertyIdMap,\n            naive=True,\n            lang=self.config.lang,\n            listSeparator=self.config.list_separator,\n        )\n        naiveSparqlQuery = Query(name=\"naive SPARQL Query\", query=sparqlQuery)\n        self.naive_query_view.show_query(naiveSparqlQuery.query)\n        sparqlQuery = tt.generateSparqlQuery(\n            genMap=propertyIdMap,\n            naive=False,\n            lang=self.config.lang,\n            listSeparator=self.config.list_separator,\n        )\n        self.aggregateSparqlQuery = Query(\n            name=\"aggregate SPARQL Query\", query=sparqlQuery\n        )\n        self.aggregate_query_view.show_query(self.aggregateSparqlQuery.query)\n        ui.notify(\"SPARQL queries generated\")\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.getPropertyIdMap","title":"<code>getPropertyIdMap()</code>  <code>async</code>","text":"<p>get the map of selected property ids with generation specs</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>a dict of list</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>async def getPropertyIdMap(self) -&gt; Dict:\n    \"\"\"\n    get the map of selected property ids\n    with generation specs\n\n    Returns:\n        dict: a dict of list\n    \"\"\"\n    idMap = {}\n    cols = self.property_selection.checkbox_cols\n    selected_rows = await self.property_grid.get_selected_rows()\n    for srow in selected_rows:\n        propertyId = srow[\"propertyId\"]\n        key_value = srow[\"#\"]\n        genList = []\n        for col_key in cols:\n            checked = self.property_grid.get_cell_value(key_value, col_key)\n            if checked:\n                genList.append(col_key)\n        idMap[propertyId] = genList\n    return idMap\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.get_stats_rows","title":"<code>get_stats_rows(property_grid_rows)</code>","text":"<p>get the statistic rows for the given property_grid_rows</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def get_stats_rows(self, property_grid_rows: list):\n    \"\"\"\n    get the statistic rows for the given property_grid_rows\n    \"\"\"\n    for row in property_grid_rows:\n        property_id = row[\"propertyId\"]\n        row_key = row[\"#\"]\n        stats_row = self.wikiTrulyTabularPropertyStats(self.tt.itemQid, property_id)\n        if stats_row:\n            stats_row[\"\u2714\"] = \"\u2714\"\n        else:\n            stats_row = {\"\u2714\": \"\u274c\"}\n        for col_key, statsColumn in [\n            (\"1\", \"1\"),\n            (\"maxf\", \"maxf\"),\n            (\"nt\", \"non tabular\"),\n            (\"nt%\", \"non tabular%\"),\n            (\"?f\", \"queryfTryIt\"),\n            (\"?ex\", \"queryexTryIt\"),\n            (\"\u2714\", \"\u2714\"),\n        ]:\n            if statsColumn in stats_row:\n                value = stats_row[statsColumn]\n                self.property_grid.update_cell(row_key, col_key, value)\n        self.property_grid.update()\n        pass\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.isTimeoutException","title":"<code>isTimeoutException(ex)</code>  <code>staticmethod</code>","text":"<p>Checks if the given exception is a query timeout exception</p> <p>Returns:</p> Type Description <p>True if the given exception is caused by a query timeout</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>@staticmethod\ndef isTimeoutException(ex: EndPointInternalError):\n    \"\"\"\n    Checks if the given exception is a query timeout exception\n\n    Returns:\n        True if the given exception is caused by a query timeout\n    \"\"\"\n    check_for = \"java.util.concurrent.TimeoutException\"\n    msg = ex.args[0]\n    res = False\n    if isinstance(msg, str):\n        if check_for in msg:\n            res = True\n    return res\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.on_generate_button_click","title":"<code>on_generate_button_click(_event)</code>  <code>async</code>","text":"<p>handle the generate button click</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>async def on_generate_button_click(self, _event):\n    \"\"\"\n    handle the generate button click\n    \"\"\"\n    try:\n        ui.notify(f\"generating SPARQL query for {str(self.tt)}\")\n        await self.generateQueries()\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.on_min_property_frequency_change","title":"<code>on_min_property_frequency_change(_event)</code>  <code>async</code>","text":"<p>handle a change in the minimum property frequency input</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>async def on_min_property_frequency_change(self, _event):\n    \"\"\"\n    handle a change in the minimum property frequency input\n    \"\"\"\n    value_str = self.min_property_frequency_input.value\n    try:\n        self.config.min_property_frequency = float(value_str)\n        ui.notify(f\"new freq: {self.config.min_property_frequency}\")\n        await self.update_display()\n    except Exception as _ex:\n        ui.notify(f\"invalid frequency value {value_str}\")\n        pass\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.on_pareto_change","title":"<code>on_pareto_change(_event)</code>  <code>async</code>","text":"<p>handle changes in the pareto level</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>async def on_pareto_change(self, _event):\n    \"\"\"\n    handle changes in the pareto level\n    \"\"\"\n    ui.notify(f\"pareto level changed to {self.config.pareto_level} \")\n    self.config.min_property_frequency = self.config.pareto.asPercent()\n    self.min_property_frequency_input.value = str(\n        self.config.min_property_frequency\n    )\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.on_property_grid_selection_change","title":"<code>on_property_grid_selection_change(event)</code>  <code>async</code>","text":"<p>the property grid selection has changed</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>async def on_property_grid_selection_change(self, event):\n    \"\"\"\n    the property grid selection has changed\n    \"\"\"\n    source = event.args.get(\"source\", None)\n    if source == \"checkboxSelected\":\n        selected_rows = await self.property_grid.get_selected_rows()\n        ui.notify(f\"Selection changed: {selected_rows}\")\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.prepare_generation_specs","title":"<code>prepare_generation_specs()</code>","text":"<p>prepare the interactive generation specification</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def prepare_generation_specs(self):\n    \"\"\"\n    prepare the interactive generation specification\n    \"\"\"\n    # render generation spec columns as checkboxes\n    for col in self.property_selection.checkbox_cols:\n        self.property_grid.set_checkbox_renderer(col)\n        pass\n    for row in self.property_selection.propertyList:\n        has_min_frequency = self.property_selection.hasMinFrequency(row)\n        row[\"count\"] = True\n        if has_min_frequency:\n            if row[\"type\"] == \"WikibaseItem\":\n                row[\"label\"] = True\n        else:\n            row[\"ignore\"] = True\n        pass\n    col_def = self.property_grid.get_column_def(\"#\")\n    col_def[\"headerCheckboxSelection\"] = True\n    self.property_grid.update()\n    self.property_grid.select_all_rows()\n    self.generate_button.enable()\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.setup","title":"<code>setup()</code>","text":"<p>set up the user interface</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def setup(self):\n    \"\"\"\n    set up the user interface\n    \"\"\"\n    with ui.element(\"div\").classes(\"w-full\") as self.main_container:\n        with ui.splitter() as splitter:\n            with splitter.before:\n                with ui.row() as self.sp_row:\n                    self.item_input = ui.input(\n                        \"item\", value=self.qid, on_change=self.update_display\n                    ).bind_value(self, \"qid\")\n                    predicates = {\n                        \"wdt:P31\": \"instance of\",\n                        \"wdt:P31/wdt:P279*\": \"subclass of\",\n                        \"wdt:P179\": \"part of the series\",\n                    }\n                    self.solution.add_select(\n                        \"predicate\",\n                        predicates,\n                        with_input=True,\n                        value=self.search_predicate,\n                        on_change=self.update_display,\n                    ).bind_value(self, \"search_predicate\")\n\n                with ui.row() as self.item_row:\n                    self.item_link_view = ui.html()\n                    self.item_count_view = ui.html()\n                with ui.row():\n                    self.solution.add_select(\n                        \"Pareto level\",\n                        self.config.pareto_select,\n                        on_change=self.on_pareto_change,\n                    ).bind_value(self.config, \"pareto_level\")\n                    self.min_property_frequency_input = ui.input(\n                        \"min%\",\n                        value=str(self.config.min_property_frequency),\n                    ).on(\"keydown.enter\", self.on_min_property_frequency_change)\n            with splitter.after as self.query_display_container:\n                self.count_query_view = QueryView(\n                    self.solution,\n                    name=\"count Query\",\n                    sparql_endpoint=self.config.sparql_endpoint,\n                )\n                self.property_query_view = QueryView(\n                    self.solution,\n                    name=\"property Query\",\n                    sparql_endpoint=self.config.sparql_endpoint,\n                )\n        with ui.row() as self.generate_button_row:\n            self.generate_button = ui.button(\n                \"Generate SPARQL queries\", on_click=self.on_generate_button_click\n            )\n            self.generate_button.disable()\n        with ui.row() as self.progressbar_row:\n            self.progress_bar = NiceguiProgressbar(\n                total=0, desc=\"Property statistics\", unit=\"prop\"\n            )\n        with ui.row() as self.property_grid_row:\n            config = GridConfig(multiselect=True)\n            self.property_grid = ListOfDictsGrid(config=config)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.update_display","title":"<code>update_display()</code>  <code>async</code>","text":"<p>update the display</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>async def update_display(self):\n    \"\"\"\n    update the display\n    \"\"\"\n    try:\n        if self.solution.log_view:\n            self.solution.log_view.clear()\n        self.tt = self.createTrulyTabular(self.qid)\n        for query_view in self.count_query_view, self.property_query_view:\n            query_view.sparql_endpoint = self.config.sparql_endpoint\n        # Initialize TrulyTabular with the qid\n        await self.update_item_link_view()\n        await run.io_bound(self.update_item_count_view)\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.update_item_count_view","title":"<code>update_item_count_view()</code>","text":"<p>update the item count</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def update_item_count_view(self):\n    \"\"\"\n    update the item count\n    \"\"\"\n    try:\n        self.ttcount, countQuery = self.tt.count()\n        self.count_query_view.show_query(countQuery)\n        content = \"\u2753\" if self.tt.error else f\"{self.ttcount} instances found\"\n        with self.item_row:\n            self.item_count_view.content = content\n        if not self.tt.error:\n            self.update_property_query_view(total=self.ttcount)\n\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.update_properties_table","title":"<code>update_properties_table(mfp_query)</code>","text":"<p>update my properties table</p> <p>Parameters:</p> Name Type Description Default <code>mfp_query(Query)</code> <p>the query for the most frequently used properties</p> required Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def update_properties_table(self, mfp_query):\n    \"\"\"\n    update my properties table\n\n    Args:\n        mfp_query(Query): the query for the most frequently used properties\n    \"\"\"\n    try:\n        with self.query_display_container:\n            msg = f\"running query for most frequently used properties of {str(self.tt)} ...\"\n            ui.notify(msg)\n        try:\n            property_lod = self.tt.sparql.queryAsListOfDicts(mfp_query.query)\n        except EndPointInternalError as ex:\n            if self.isTimeoutException(ex):\n                raise Exception(\"Query timeout of the property table query\")\n        self.property_selection = PropertySelection(\n            property_lod,\n            total=self.ttcount,\n            paretoLevels=self.config.pareto_levels,\n            minFrequency=self.config.min_property_frequency,\n        )\n        self.property_selection.prepare()\n        with self.property_grid_row:\n            self.view_lod = self.property_selection.propertyList\n            self.property_grid.load_lod(self.view_lod)\n            self.property_grid.set_checkbox_selection(\"#\")\n            self.property_grid.update()\n        self.update_property_stats()\n        self.prepare_generation_specs()\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.update_property_query_view","title":"<code>update_property_query_view(total)</code>","text":"<p>update the property query view</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def update_property_query_view(self, total: int):\n    \"\"\"\n    update the property query view\n    \"\"\"\n    try:\n        pareto = self.config.pareto\n        if total is not None:\n            min_count = round(total * self.config.min_property_frequency / 100.0)\n        else:\n            min_count = 0\n        msg = f\"searching properties with at least {min_count} usages\"\n        with self.main_container:\n            ui.notify(msg)\n        mfp_query = self.tt.mostFrequentPropertiesQuery(minCount=min_count)\n        self.property_query_view.show_query(mfp_query.query)\n        self.update_properties_table(mfp_query)\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.update_property_stats","title":"<code>update_property_stats()</code>","text":"<p>update the property statistics</p> Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def update_property_stats(self):\n    \"\"\"\n    update the property statistics\n    \"\"\"\n    try:\n        count = len(self.property_selection.propertyList)\n        with self.main_container:\n            ui.notify(f\"Getting property statistics for {count} properties\")\n            self.progress_bar.total = count\n            self.progress_bar.reset()\n        for row in self.property_selection.propertyList:\n            # run in background\n            asyncio.run(run.io_bound(self.get_stats_rows, [row]))\n            with self.main_container:\n                self.progress_bar.update(1)\n        pass\n        with self.main_container:\n            self.progress_bar.reset()\n            ui.notify(f\"Done getting statistics for {count} properties\")\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#wd.truly_tabular_display.TrulyTabularDisplay.wikiTrulyTabularPropertyStats","title":"<code>wikiTrulyTabularPropertyStats(itemId, propertyId)</code>","text":"<p>get the truly tabular property statistics</p> <p>Parameters:</p> Name Type Description Default <code>itemId(str)</code> <p>the Wikidata item identifier</p> required <code>propertyId(str)</code> <p>the property id</p> required Source code in <code>wd/truly_tabular_display.py</code> <pre><code>def wikiTrulyTabularPropertyStats(self, itemId: str, propertyId: str):\n    \"\"\"\n    get the truly tabular property statistics\n\n    Args:\n        itemId(str): the Wikidata item identifier\n        propertyId(str): the property id\n    \"\"\"\n    try:\n        tt = self.createTrulyTabular(itemId, propertyIds=[propertyId])\n        statsRow = next(tt.genPropertyStatistics())\n        for key in [\"queryf\", \"queryex\"]:\n            queryText = statsRow[key]\n            sparql = f\"# This query was generated by Truly Tabular\\n{queryText}\"\n            query = Query(name=key, query=sparql)\n            tryItUrlEncoded = query.getTryItUrl(\n                baseurl=self.config.sparql_endpoint.website,\n                database=self.config.sparql_endpoint.database,\n            )\n            tryItLink = Link.create(\n                url=tryItUrlEncoded,\n                text=\"try it!\",\n                tooltip=f\"try out with {self.config.sparql_endpoint.name}\",\n                target=\"_blank\",\n            )\n            statsRow[f\"{key}TryIt\"] = tryItLink\n        return statsRow\n    except (BaseException, HTTPError) as ex:\n        self.solution.handle_exception(ex)\n        return None\n</code></pre>"},{"location":"#wd.version","title":"<code>version</code>","text":"<p>Created on 2024-01-02</p> <p>@author: wf</p>"},{"location":"#wd.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for wdgrid</p> Source code in <code>wd/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for wdgrid\n    \"\"\"\n\n    name = \"wdgrid\"\n    version = wd.__version__\n    description = \"wikdata grid and sync\"\n    date = \"2021-12-12\"\n    updated = \"2024-03-07\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/Wdgrid\"\n    chat_url = \"https://github.com/WolfgangFahl/wdgrid/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/wdgrid\"\n\n    license = f\"\"\"Copyright 2023 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#wd.wdgrid_cmd","title":"<code>wdgrid_cmd</code>","text":"<p>Created on 2024-01-03</p> <p>@author: wf</p>"},{"location":"#wd.wdgrid_cmd.WdgridCmd","title":"<code>WdgridCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>Command line for wiki data grid web server</p> Source code in <code>wd/wdgrid_cmd.py</code> <pre><code>class WdgridCmd(WebserverCmd):\n    \"\"\"\n    Command line for wiki data grid web server\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"-en\",\n            \"--endpointName\",\n            default=\"wikidata\",\n            help=f\"Name of the endpoint to use for queries. Available by default: {EndpointManager.getEndpointNames(lang='sparql')}\",\n        )\n        return parser\n</code></pre>"},{"location":"#wd.wdgrid_cmd.WdgridCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>wd/wdgrid_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"-en\",\n        \"--endpointName\",\n        default=\"wikidata\",\n        help=f\"Name of the endpoint to use for queries. Available by default: {EndpointManager.getEndpointNames(lang='sparql')}\",\n    )\n    return parser\n</code></pre>"},{"location":"#wd.wdgrid_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>wd/wdgrid_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = WdgridCmd(config=WdgridWebServer.get_config(), webserver_cls=WdgridWebServer)\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#wd.wditem_search","title":"<code>wditem_search</code>","text":"<p>Created on 2024-01-03</p> <p>@author: wf</p>"},{"location":"#wd.wditem_search.WikidataItemSearch","title":"<code>WikidataItemSearch</code>","text":"<p>wikidata item search</p> Source code in <code>wd/wditem_search.py</code> <pre><code>class WikidataItemSearch:\n    \"\"\"\n    wikidata item search\n    \"\"\"\n\n    def __init__(self, webserver: NiceGuiWebserver, record_filter: Callable = None):\n        \"\"\"\n        Initialize the WikidataItemSearch with the given webserver.\n\n        Args:\n            webserver (NiceGuiWebserver): The webserver to attach the search UI.\n            record_filter(Callable): callback for displayed found records\n        \"\"\"\n        self.webserver = webserver\n        self.record_filter = record_filter\n        self.limit = 9\n        self.wd_search = WikidataSearch(self.webserver.tt_config.lang)\n        self.search_debounce_task = None\n        self.keyStrokeTime = 0.65  # minimum time in seconds to wait between keystrokes before starting searching\n        self.search_result_row = None\n        self.setup()\n\n    def setup(self):\n        \"\"\"\n        setup the user interface\n        \"\"\"\n        with ui.card().style(\"width: 25%\"):\n            with ui.grid(rows=1, columns=4):\n                ui.label(\"limit:\")\n                self.limit_slider = (\n                    ui.slider(min=2, max=50, value=self.limit)\n                    .props(\"label-always\")\n                    .bind_value(self, \"limit\")\n                )\n            with ui.row():\n                self.search_input = ui.input(\n                    label=\"search\", on_change=self.on_search_change\n                ).props(\"size=80\")\n        with ui.row() as self.search_result_row:\n            self.search_result_grid = ListOfDictsGrid()\n\n    async def on_search_change(self, _args):\n        \"\"\"\n        react on changes in the search input\n        \"\"\"\n        # Cancel the existing search task if it's still waiting\n        if self.search_debounce_task:\n            self.search_debounce_task.cancel()\n\n        # Create a new task for the new search\n        self.search_debounce_task = asyncio.create_task(self.debounced_search())\n\n    async def debounced_search(self):\n        \"\"\"\n        Waits for a period of inactivity and then performs the search.\n        \"\"\"\n        try:\n            # Wait for the debounce period (keyStrokeTime)\n            await asyncio.sleep(self.keyStrokeTime)\n            search_for = self.search_input.value\n            if self.search_result_row:\n                with self.search_result_row:\n                    lang = self.webserver.tt_config.lang\n                    ui.notify(f\"searching wikidata for {search_for} ({lang})...\")\n                    self.wd_search.language = lang\n                    wd_search_result = self.wd_search.searchOptions(\n                        search_for, limit=self.limit\n                    )\n                    view_lod = self.get_selection_view_lod(wd_search_result)\n                    self.search_result_grid.load_lod(view_lod)\n                    # self.search_result_grid.set_checkbox_selection(\"#\")\n                    self.search_result_grid.update()\n        except asyncio.CancelledError:\n            # The search was cancelled because of new input, so just quietly exit\n            pass\n        except BaseException as ex:\n            self.webserver.handle_exception(ex, self.webserver)\n\n    def get_selection_view_lod(self, wd_search_result: list) -&gt; dict:\n        \"\"\"\n        Convert the Wikidata search result list of dict to a selection.\n\n        Args:\n            wd_search_result (List[Dict[str, Any]]): The search results from Wikidata.\n\n        Returns:\n            List[Dict[str, Any]]: The list of dictionaries formatted for view.\n        \"\"\"\n        view_lod = []\n        for qid, itemLabel, desc in wd_search_result:\n            url = f\"https://www.wikidata.org/wiki/{qid}\"\n            link = Link.create(url, qid)\n            row = {\n                \"#\": len(view_lod) + 1,\n                \"qid\": link,\n                \"label\": itemLabel,\n                \"desc\": desc,\n            }\n            if self.record_filter:\n                self.record_filter(qid, row)\n            view_lod.append(row)\n        return view_lod\n</code></pre>"},{"location":"#wd.wditem_search.WikidataItemSearch.__init__","title":"<code>__init__(webserver, record_filter=None)</code>","text":"<p>Initialize the WikidataItemSearch with the given webserver.</p> <p>Parameters:</p> Name Type Description Default <code>webserver</code> <code>NiceGuiWebserver</code> <p>The webserver to attach the search UI.</p> required <code>record_filter(Callable)</code> <p>callback for displayed found records</p> required Source code in <code>wd/wditem_search.py</code> <pre><code>def __init__(self, webserver: NiceGuiWebserver, record_filter: Callable = None):\n    \"\"\"\n    Initialize the WikidataItemSearch with the given webserver.\n\n    Args:\n        webserver (NiceGuiWebserver): The webserver to attach the search UI.\n        record_filter(Callable): callback for displayed found records\n    \"\"\"\n    self.webserver = webserver\n    self.record_filter = record_filter\n    self.limit = 9\n    self.wd_search = WikidataSearch(self.webserver.tt_config.lang)\n    self.search_debounce_task = None\n    self.keyStrokeTime = 0.65  # minimum time in seconds to wait between keystrokes before starting searching\n    self.search_result_row = None\n    self.setup()\n</code></pre>"},{"location":"#wd.wditem_search.WikidataItemSearch.debounced_search","title":"<code>debounced_search()</code>  <code>async</code>","text":"<p>Waits for a period of inactivity and then performs the search.</p> Source code in <code>wd/wditem_search.py</code> <pre><code>async def debounced_search(self):\n    \"\"\"\n    Waits for a period of inactivity and then performs the search.\n    \"\"\"\n    try:\n        # Wait for the debounce period (keyStrokeTime)\n        await asyncio.sleep(self.keyStrokeTime)\n        search_for = self.search_input.value\n        if self.search_result_row:\n            with self.search_result_row:\n                lang = self.webserver.tt_config.lang\n                ui.notify(f\"searching wikidata for {search_for} ({lang})...\")\n                self.wd_search.language = lang\n                wd_search_result = self.wd_search.searchOptions(\n                    search_for, limit=self.limit\n                )\n                view_lod = self.get_selection_view_lod(wd_search_result)\n                self.search_result_grid.load_lod(view_lod)\n                # self.search_result_grid.set_checkbox_selection(\"#\")\n                self.search_result_grid.update()\n    except asyncio.CancelledError:\n        # The search was cancelled because of new input, so just quietly exit\n        pass\n    except BaseException as ex:\n        self.webserver.handle_exception(ex, self.webserver)\n</code></pre>"},{"location":"#wd.wditem_search.WikidataItemSearch.get_selection_view_lod","title":"<code>get_selection_view_lod(wd_search_result)</code>","text":"<p>Convert the Wikidata search result list of dict to a selection.</p> <p>Parameters:</p> Name Type Description Default <code>wd_search_result</code> <code>List[Dict[str, Any]]</code> <p>The search results from Wikidata.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>List[Dict[str, Any]]: The list of dictionaries formatted for view.</p> Source code in <code>wd/wditem_search.py</code> <pre><code>def get_selection_view_lod(self, wd_search_result: list) -&gt; dict:\n    \"\"\"\n    Convert the Wikidata search result list of dict to a selection.\n\n    Args:\n        wd_search_result (List[Dict[str, Any]]): The search results from Wikidata.\n\n    Returns:\n        List[Dict[str, Any]]: The list of dictionaries formatted for view.\n    \"\"\"\n    view_lod = []\n    for qid, itemLabel, desc in wd_search_result:\n        url = f\"https://www.wikidata.org/wiki/{qid}\"\n        link = Link.create(url, qid)\n        row = {\n            \"#\": len(view_lod) + 1,\n            \"qid\": link,\n            \"label\": itemLabel,\n            \"desc\": desc,\n        }\n        if self.record_filter:\n            self.record_filter(qid, row)\n        view_lod.append(row)\n    return view_lod\n</code></pre>"},{"location":"#wd.wditem_search.WikidataItemSearch.on_search_change","title":"<code>on_search_change(_args)</code>  <code>async</code>","text":"<p>react on changes in the search input</p> Source code in <code>wd/wditem_search.py</code> <pre><code>async def on_search_change(self, _args):\n    \"\"\"\n    react on changes in the search input\n    \"\"\"\n    # Cancel the existing search task if it's still waiting\n    if self.search_debounce_task:\n        self.search_debounce_task.cancel()\n\n    # Create a new task for the new search\n    self.search_debounce_task = asyncio.create_task(self.debounced_search())\n</code></pre>"},{"location":"#wd.wditem_search.WikidataItemSearch.setup","title":"<code>setup()</code>","text":"<p>setup the user interface</p> Source code in <code>wd/wditem_search.py</code> <pre><code>def setup(self):\n    \"\"\"\n    setup the user interface\n    \"\"\"\n    with ui.card().style(\"width: 25%\"):\n        with ui.grid(rows=1, columns=4):\n            ui.label(\"limit:\")\n            self.limit_slider = (\n                ui.slider(min=2, max=50, value=self.limit)\n                .props(\"label-always\")\n                .bind_value(self, \"limit\")\n            )\n        with ui.row():\n            self.search_input = ui.input(\n                label=\"search\", on_change=self.on_search_change\n            ).props(\"size=80\")\n    with ui.row() as self.search_result_row:\n        self.search_result_grid = ListOfDictsGrid()\n</code></pre>"},{"location":"#wd.webserver","title":"<code>webserver</code>","text":"<p>Created on 2024-01-03</p> <p>@author: wf</p>"},{"location":"#wd.webserver.WdgridSolution","title":"<code>WdgridSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>Wikidata Grid client specific UI</p> Source code in <code>wd/webserver.py</code> <pre><code>class WdgridSolution(InputWebSolution):\n    \"\"\"\n    Wikidata Grid client specific UI\n    \"\"\"\n\n    def __init__(self, webserver: WdgridWebServer, client: Client):\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.debug = webserver.debug\n        self.tt_config = TrulyTabularConfig()\n\n    async def truly_tabular(self, qid: str):\n        \"\"\"\n        show a truly tabular analysis of the given Wikidata id\n\n        Args:\n            qid(str): the Wikidata id of the item to analyze\n        \"\"\"\n\n        def show():\n            self.ttd = TrulyTabularDisplay(self, qid)\n\n        await self.setup_content_div(show)\n\n    def configure_settings(self):\n        \"\"\"\n        extra settings\n        \"\"\"\n        self.tt_config.setup_ui(self)\n\n    def prepare_ui(self):\n        \"\"\"\n        overrideable configuration\n        \"\"\"\n        self.tt_config.endpoint_name = self.args.endpointName\n\n    async def home(self):\n        \"\"\"\n        provide the main content page\n        \"\"\"\n\n        def record_filter(qid: str, record: dict):\n            if \"label\" and \"desc\" in record:\n                text = f\"\"\"{record[\"label\"]}({qid})\u261e{record[\"desc\"]}\"\"\"\n                tt_link = Link.create(f\"/tt/{qid}\", text)\n                # getting the link to be at second position\n                # is a bit tricky\n                temp_items = list(record.items())\n                # Add the new item in the second position\n                temp_items.insert(1, (\"truly tabular\", tt_link))\n\n                # Clear the original dictionary and update it with the new order of items\n                record.clear()\n                record.update(temp_items)\n\n        def show():\n            self.wd_item_search = WikidataItemSearch(self, record_filter=record_filter)\n\n        await self.setup_content_div(show)\n</code></pre>"},{"location":"#wd.webserver.WdgridSolution.configure_settings","title":"<code>configure_settings()</code>","text":"<p>extra settings</p> Source code in <code>wd/webserver.py</code> <pre><code>def configure_settings(self):\n    \"\"\"\n    extra settings\n    \"\"\"\n    self.tt_config.setup_ui(self)\n</code></pre>"},{"location":"#wd.webserver.WdgridSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>provide the main content page</p> Source code in <code>wd/webserver.py</code> <pre><code>async def home(self):\n    \"\"\"\n    provide the main content page\n    \"\"\"\n\n    def record_filter(qid: str, record: dict):\n        if \"label\" and \"desc\" in record:\n            text = f\"\"\"{record[\"label\"]}({qid})\u261e{record[\"desc\"]}\"\"\"\n            tt_link = Link.create(f\"/tt/{qid}\", text)\n            # getting the link to be at second position\n            # is a bit tricky\n            temp_items = list(record.items())\n            # Add the new item in the second position\n            temp_items.insert(1, (\"truly tabular\", tt_link))\n\n            # Clear the original dictionary and update it with the new order of items\n            record.clear()\n            record.update(temp_items)\n\n    def show():\n        self.wd_item_search = WikidataItemSearch(self, record_filter=record_filter)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#wd.webserver.WdgridSolution.prepare_ui","title":"<code>prepare_ui()</code>","text":"<p>overrideable configuration</p> Source code in <code>wd/webserver.py</code> <pre><code>def prepare_ui(self):\n    \"\"\"\n    overrideable configuration\n    \"\"\"\n    self.tt_config.endpoint_name = self.args.endpointName\n</code></pre>"},{"location":"#wd.webserver.WdgridSolution.truly_tabular","title":"<code>truly_tabular(qid)</code>  <code>async</code>","text":"<p>show a truly tabular analysis of the given Wikidata id</p> <p>Parameters:</p> Name Type Description Default <code>qid(str)</code> <p>the Wikidata id of the item to analyze</p> required Source code in <code>wd/webserver.py</code> <pre><code>async def truly_tabular(self, qid: str):\n    \"\"\"\n    show a truly tabular analysis of the given Wikidata id\n\n    Args:\n        qid(str): the Wikidata id of the item to analyze\n    \"\"\"\n\n    def show():\n        self.ttd = TrulyTabularDisplay(self, qid)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#wd.webserver.WdgridWebServer","title":"<code>WdgridWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>Server for Wikidata Grid</p> Source code in <code>wd/webserver.py</code> <pre><code>class WdgridWebServer(InputWebserver):\n    \"\"\"\n    Server for Wikidata Grid\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        \"\"\"\n        get the configuration for this Webserver\n        \"\"\"\n        copy_right = \"(c)2022-2024 Wolfgang Fahl\"\n        config = WebserverConfig(\n            short_name=\"wdgrid\",\n            copy_right=copy_right,\n            version=Version(),\n            default_port=9997,\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = WdgridSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        InputWebserver.__init__(self, config=WdgridWebServer.get_config())\n\n        @ui.page(\"/tt/{qid}\")\n        async def truly_tabular(client: Client, qid: str):\n            \"\"\"\n            initiate the truly tabular analysis for the given Wikidata QIDs\n            \"\"\"\n            await self.page(client, WdgridSolution.truly_tabular, qid)\n</code></pre>"},{"location":"#wd.webserver.WdgridWebServer.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>wd/webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    InputWebserver.__init__(self, config=WdgridWebServer.get_config())\n\n    @ui.page(\"/tt/{qid}\")\n    async def truly_tabular(client: Client, qid: str):\n        \"\"\"\n        initiate the truly tabular analysis for the given Wikidata QIDs\n        \"\"\"\n        await self.page(client, WdgridSolution.truly_tabular, qid)\n</code></pre>"},{"location":"#wd.webserver.WdgridWebServer.get_config","title":"<code>get_config()</code>  <code>classmethod</code>","text":"<p>get the configuration for this Webserver</p> Source code in <code>wd/webserver.py</code> <pre><code>@classmethod\ndef get_config(cls) -&gt; WebserverConfig:\n    \"\"\"\n    get the configuration for this Webserver\n    \"\"\"\n    copy_right = \"(c)2022-2024 Wolfgang Fahl\"\n    config = WebserverConfig(\n        short_name=\"wdgrid\",\n        copy_right=copy_right,\n        version=Version(),\n        default_port=9997,\n    )\n    server_config = WebserverConfig.get(config)\n    server_config.solution_class = WdgridSolution\n    return server_config\n</code></pre>"}]}